# Copyright 2022-2024 Rigetti & Co, LLC
#
# This Computer Software is developed under Agreement HR00112230006 between Rigetti & Co, LLC and
# the Defense Advanced Research Projects Agency (DARPA). Use, duplication, or disclosure is subject
# to the restrictions as stated in Agreement HR00112230006 between the Government and the Performer.
# This Computer Software is provided to the U.S. Government with Unlimited Rights; refer to LICENSE
# file for Data Rights Statements. Any opinions, findings, conclusions or recommendations expressed
# in this material are those of the author(s) and do not necessarily reflect the views of the DARPA.
#
# Use of this work other than as specifically authorized by the U.S. Government is licensed under
# the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

"""
A collection of unit tests to robustly verify AGSs from Jabalizer (our default FT-compiler) as used in RRE pipeline.


Parts of the following code are inspired and/or customized from the original templates in the open-source reference of:
[1] https://github.com/QSI-BAQS/Jabalizer.jl
"""

import json

import qiskit
from qiskit_aer import AerSimulator

from rigetti_resource_estimation.estimation_pipeline import estimation_pipeline
from rigetti_resource_estimation.jabalizer_wrapper import get_mbqc_data_from_jabalizejson


def simulate(
    input_qasm_path: str,
    mbqc_qasm_path: str,
    shots: int,
    data_qubits: dict,
):
    """
    Perform qiskit (near-)exact simulation of the quantum circ in MBQC picture for verification purposes.

    See `test_verify_jabalizer_QFT4_graph()` for some more details.

    :param input_qasm_path: filepath string for the full QASM of the input algorithm.
    :param mbqc_qasm_path: filepath string for the MBQC-formatted QASM generated by Jabalizer given the input algorithm.
    :param shots: number of shots for QISKIT simulations.
    :param data_qubits: A Jabalizer-generated dict of data_qubits for the input algorithm containing `output`, `input`,
        and `state_layer` qubit information.

    Original work from:
    https://github.com/QSI-BAQS/Jabalizer.jl/blob/track_paulis_bit_frames/test_scripts/check.py by @taeruh
    https://github.com/QSI-BAQS/Jabalizer.jl/blob/main/test/circuit_sim.jl by @madhavkrishnan
    """
    output_qubits = data_qubits["output"]
    state_qubits = data_qubits["state"]

    if not all([i == 0 for i in data_qubits["state_layer"]]):
        raise RuntimeError(
            "The path in `data_qubits` was not time-optimal. Currently, we only support the trivial time-optimal path "
            "for Jabalizer's verification tests."
        )

    aer_simulator = AerSimulator(method="matrix_product_state")

    input_circ = qiskit.QuantumCircuit.from_qasm_file(input_qasm_path)
    cc = qiskit.QuantumCircuit.from_qasm_file(mbqc_qasm_path)
    cc.barrier()

    qtot = len(output_qubits)
    meas_outcomes = []
    for ii in range(2**qtot - 1):
        new_circ = cc.compose(input_circ.inverse(), output_qubits)
        input_state = qiskit.QuantumCircuit(qtot)  # specifying the input state

        x_locs = format(ii, "0" + str(qtot) + "b")
        x_locs = [int(d) for d in list(x_locs)]
        x_locs = [ind for ind, bit in enumerate(x_locs) if bit == 1]
        if len(x_locs):
            input_state.x(x_locs)

        # append input state and invert at output
        new_circ = new_circ.compose(input_state, qubits=state_qubits, front=True)  # type: ignore
        new_circ = new_circ.compose(input_state.inverse(), qubits=output_qubits)  # type: ignore

        for q in output_qubits:
            new_circ.measure(q, q)  # type: ignore

        job = aer_simulator.run(new_circ, shots=shots)
        result = job.result()
        measured_statistics = qiskit.result.marginal_counts(result, indices=output_qubits).get_counts()  # type: ignore

        # Extracting the statistics for all-zero state
        all0_state = "0 " * qtot
        all0_state = all0_state[:-1]
        meas_for_all0 = measured_statistics[all0_state]
        meas_outcomes.append(meas_for_all0)

    return meas_outcomes


def test_verify_jabalizer_qft4(tmp_path):
    """
    A series of QFT4 graph-state robust verification tests for Jablizer compiler and its underlying tools.

    The inputs are the logical algorithm unitary, say U_{QFT4}, and a corresponding number of quantum registers all
    initiated at zero state. We first create an AGS from U_{QFT4} using latest Jabalizer compiler, which also attach
    Pauli Tracker frames information. We then create the unique MBQC-style circuits from this AGS, which we call
    U^{Jabalizer}_{QFT4}. We apply U^{Jabalizer}_{QFT4} circuit to an all-zero-initialized states through a QISKIT
    (near-)exact simulator. We next apply an independently-created reverse-QFT4 algorithm to the qubits,
    U^{Dagger}_{QFT4}. If the graph was valid the final PDF result must corresponds to all-zero state again.

    We are testing two scenarios of a single widget and stitched blocks as detailed below.

    Parts of this test are taken from:
    https://github.com/QSI-BAQS/Jabalizer.jl/blob/track_paulis/test_scripts/check.py by @taeruh
    https://github.com/QSI-BAQS/Jabalizer.jl/blob/main/test/qasm_simulation.jl by @madhavkrishnan
    """
    shots = 1024
    jabalize_json = "output/qft4/qft4_all0init_jabalizeframes.json"  # the unified jabalize JSON file
    mbqc_compiled_qasm = tmp_path / "mbqc_compiled_qasm.qasm"
    dqubits_json = tmp_path / "mbqc_compiled_qasm_dqubits.json"
    circ_singlegraph = "./examples/input/qft4.qasm"

    # Scenario 1: a single graph and Jabalize JSON are directly generated from QFT4 circuit
    estimation_pipeline(
        circ_path=circ_singlegraph,
        graph_state_opt="save",
        pcorrections_flag=True,
    )

    get_mbqc_data_from_jabalizejson(mbqc_output_qasm=str(mbqc_compiled_qasm), jabalize_json=jabalize_json)
    with open(dqubits_json, encoding="utf8") as f:
        dq = json.load(f)

    meas_outcomes_singlegraph = simulate(
        input_qasm_path=circ_singlegraph,
        mbqc_qasm_path=mbqc_compiled_qasm,
        shots=shots,
        data_qubits=dq,
    )
    print(f"meas_outcomes_singlegraph: {meas_outcomes_singlegraph}")

    # TODO: Scenario 2: Full graph and JSONs are generated from time-like stitched trio of **subgraphs** as instructed
    # by "qft4-decomposed3.json" subcircuits. We also need to provide a decomposed circ_triograph JSON circuit for
    # stitching verification tests.

    meas_expected = [shots] * 16

    assert all([a == b for a, b in zip(meas_outcomes_singlegraph, meas_expected)])
    # assert all([a == b for a, b in zip(meas_outcomes_graphtrio, meas_expected)])
