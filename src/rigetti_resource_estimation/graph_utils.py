# Copyright 2022-2024 Rigetti & Co, LLC
#
# This Computer Software is developed under Agreement HR00112230006 between Rigetti & Co, LLC and
# the Defense Advanced Research Projects Agency (DARPA). Use, duplication, or disclosure is subject
# to the restrictions as stated in Agreement HR00112230006 between the Government and the Performer.
# This Computer Software is provided to the U.S. Government with Unlimited Rights; refer to LICENSE
# file for Data Rights Statements. Any opinions, findings, conclusions or recommendations expressed
# in this material are those of the author(s) and do not necessarily reflect the views of the DARPA.
#
# Use of this work other than as specifically authorized by the U.S. Government is licensed under
# the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License
# is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
# or implied. See the License for the specific language governing permissions and limitations under
# the License.

"""
**Module** ``rigetti_resource_estimation.graph_utils``

A set of utility functions and classes to generate and manipulate graph states for the purpose of resource estimations.
"""

import math
import logging
from pathlib import Path
from typing import Optional, Tuple, Literal, List
from dataclasses import dataclass, replace

import json
import networkx as nx

from graph_state_generation.optimizers import greedy_stabilizer_measurement_scheduler
from graph_state_generation.substrate_scheduler import TwoRowSubstrateScheduler

logger = logging.getLogger(__name__)


@dataclass
class JabalizerSchedGraphItems:
    """
    A class to keep track of the graph state attributes for graphs generated by FT-compilers.

    The FT-compiler can be Jabalizer (for example) typically followed by Substrate Scheduler processing. It is more
    efficient and safer to store and manipulate NetworkX graph attributes rather than the original graph itself.

    :param rz_count: number of non-Clifford Rz gates associated with the graph, and also, original logical circuit.
    :param t_count_init: the initial T-count associated with input logical circuit prior to Clifford+T decompositions.
    :param clifford_count_init: number of explicit Clifford gates in the initial logical circuit.
    :param big_n: total number of graph nodes.
    :param delta: maximum number of logical qubits (max memory), required at any moment, based on initial data.
    :param prep_sched: the substrate schedule for the execution of stabalizer measurements to prepare/initialize the
        graph.
    :param consump_sched: the schedule, provided by the Pauli Tracker, to consume the graph and execute the fault
        tolerant algorithm.
    :param measurement_basis_list: A list of measurement bases from the Pauli tracker, where each member is a list
        containing the bases that belong to the corresponding step of schedules.
    :param input_nodes: A list of input nodes, where each member is a list containing the input nodes that belong to
        the corresponding step of schedules.
    :param output_nodes: A list of output nodes, where each member is a list containing the output nodes that belong to
        the corresponding step of schedules.
    :param widget_cond_20to4: When True, the selected distillation widgets to feed the graph state are of `20to4` type.
    :param t_length_unit: the T-length of gate-synth chain for each Clifford+T decomposition of small angles.
    :param t_counting_cond: A flag to identify if T-counting approach was requested as the est method.
    """

    rz_count: int
    t_count_init: int
    clifford_count_init: int
    big_n: Optional[int] = None
    delta: Optional[int] = None
    prep_sched: Optional[list] = None
    consump_sched: Optional[list] = None
    measurement_basis_list: Optional[list] = None
    input_nodes: Optional[List[list]] = None
    output_nodes: Optional[List[list]] = None
    widget_cond_20to4: Optional[bool] = False
    t_length_unit: int = 1
    t_counting_cond: bool = False

    def __post_init__(self):
        """Post-process some of the initialize attributes."""
        if self.t_counting_cond:
            # Considers the worst case scenario of fully connected graphs useful for T-counting methos: the max graph
            # node degree is a proxy for delta and is set equal to T-count>>1.
            self.delta = self.t_count_init + self.rz_count * self.t_length_unit

        if self.t_counting_cond:
            # Considers the worst case scenario of fully connected graphs useful for T-counting methods: number of graph
            # nodes equals to the total T-count.
            self.big_n = self.t_count_init + self.rz_count * self.t_length_unit
        else:
            # Supposing a Jabalizer-based approach
            if self.widget_cond_20to4 is True:
                self.big_n = math.ceil((self.big_n or 0) / 4)

    def big_s_prep(self) -> int:
        """Total number of distinct measurement steps from the graph preparation schedule."""
        if self.prep_sched is not None:
            subsched_lengths = [len(subsched) for subsched in self.prep_sched]
            return sum(subsched_lengths)
        return 0

    def big_s_consump(self) -> int:
        """Total number of distinct measurement steps from the graph consumption schedule."""
        if self.consump_sched is not None:
            subsched_lengths = [len(subsched) for subsched in self.consump_sched]
            return sum(subsched_lengths)
        return 0

    def t_count(self) -> int:
        """Calculate total no. of T-basis measurements required at the distillation stage.

        Jabalizer only consumes Rz and T gates. We crudely assume there are one node in the graph state for each
        arbitrary Rz rotation and T, which also implies an upper bound estimate for time costs.
        """
        t_count = self.t_count_init + self.rz_count * self.t_length_unit
        if self.widget_cond_20to4 is True:
            t_count = math.ceil(t_count / 4)
        return t_count


def calculate_t_length_unit(const: Tuple[float, float], epsilon: float) -> int:
    """Calculate the length of T-gates required for small angle decomposition for an algorithm using given ``const``.

    Currently, this in only required at the measurement points of the distillation stage, where gate synthesize
    to Clifford+T is performed to align rotation axes.

    :param const: set the constants required for gate-synth small-angle unitary decompositions.
    :param epsilson: the epsilon for Clifford+T decompositions of small angle rotations.

    :returns: the T-length of gate-synth chain for each Clifford+T decomposition of small angles.
    """
    return math.ceil(const[0] * math.log2(1 / epsilon) + const[1])


def perform_substrate_scheduling(graph) -> Tuple[nx.Graph, List[List[Tuple[int, Tuple[int, int]]]]]:
    """Perform substrate scheduling for the consumption of a graph state and generate a schedule of measurements.

    This function uses substrate scheduling, compiling, and DAG tools from the open-source references:
    [1] https://github.com/zapatacomputing/benchq
    [2] https://github.com/QSI-BAQS/Jabalizer.jl
    [3] https://github.com/sfc-aqua/gosc-graph-state-generation

    :param graph: A NetworkX graph state, supposed to be pre-processed by an fault tolerant compiler such as Jabalizer.

    :returns:
        `graph`: A version of input graph state with no disconnected nodes.
        `schedule`: the substrate schedule for the preparation/initialization of the graph.
    """
    connected_graph = graph.copy()
    connected_graph.remove_nodes_from(list(nx.isolates(connected_graph)))  # removing isolated nodes
    connected_graph = nx.convert_node_labels_to_integers(connected_graph)

    scheduler_only_compiler = TwoRowSubstrateScheduler(
        connected_graph,
        stabilizer_scheduler=greedy_stabilizer_measurement_scheduler,
    )
    scheduler_only_compiler.run()
    prep_schedule = scheduler_only_compiler.measurement_steps

    logger.debug(
        "Substrate scheduling completed. The stab measurements required to initialize the graph state are:"
        f"\n{prep_schedule}\n"
    )
    # Some other viz tools avail: scheduler_only_compiler.stabilizer_table(), scheduler_only_compiler.visualization()

    return connected_graph, prep_schedule


class GraphCompiler:
    """A class to host fault tolerant compilation methods and generate graph states based on user choices."""

    def __init__(
        self,
        circuits_qasm: list,
        circuit_fname: str,
        num_subcircuits: int,
        graph_state_opt: Literal["no_compile", "save", "resume"],
        rz_count: int,
        t_count_init: int,
        clifford_count_init: int,
        pcorrections_flag: bool,
    ):
        """Initialize some graph state parameters based on user inputs.

        :param circuits_qasm: a list of logical-level circuits in OpenQASM2.0 format.
        :param circuit_fname: the stem for the logical circuit file path.
        :param num_subcircuits: number of subcircuits to compile.
        :param graph_state_opt: What to do with respect to the graph state compilation. Options are explained below.
            'no_compile': The graph compilation pipeline will NOT be executed (relevant for, e.g., for 't_counting'
            approaches).
            'save': RRE compiles the circuit attempting to generate the graph state and Pauli Frames info using
            Jabalizer compiler. The program will save BOTH the graph and logical_ops alongside all Pauli Frames info
            in two JSON files in the subdirectory `output/<circuit_fname>/`. The outputs will be named
            `<circuit_fname>_all0init_jabalize.json` and `<circuit_fname>_all0init_frames.json`, respectively.
            'resume': RRE will try to resume the calculations assuming an `<circuit_fname>_all0init_jabalize.json` graph
            already exist in `output/<circuit_fname>/` subdirectory.
        :param rz_count: number of the non-Clifford Rz gates associated with the original logical circuit.
        :param t_count_init: the initial T-count associated with the input logical circuit prior to Clifford+T
            decompositions.
        :param clifford_count_init: number of explicit Clifford gates in the initial logical circuit.
        :param pcorrections_flag: flag to indicate whether or not to track Pauli correction frames during compilation.
        """
        self.circuits_qasm = circuits_qasm
        self.graph_state_opt = graph_state_opt
        self.circuit_fname = circuit_fname
        self.num_subcircuits = num_subcircuits
        self.t_count_init = t_count_init
        self.clifford_count_init = clifford_count_init
        self.rz_count = rz_count
        self.pcorrections_flag = pcorrections_flag

    def append_graph_items(
        self,
        graph_items: JabalizerSchedGraphItems,
        jabalize_json_path: str,
    ) -> JabalizerSchedGraphItems:
        """Append the input graph_items using the `jabalize_json_path` source."""
        # Importing outside top-level to avoid julia (pre-)compilations upon every call to RRE.
        import rigetti_resource_estimation.jabalizer_wrapper as jw  # pylint: disable=C0415

        with open(jabalize_json_path, encoding="utf8") as f:
            jabalize_data = json.load(f)

        big_n = graph_items.big_n or 0
        consump_sched = [[]] if not graph_items.consump_sched else graph_items.consump_sched + [[]]
        prep_schedule = [[]] if not graph_items.prep_sched else graph_items.prep_sched + [[]]
        delta = 0 if not graph_items.delta else graph_items.delta
        measurement_basis_list = (
            [jabalize_data["measurements"]]
            if not graph_items.measurement_basis_list
            else graph_items.measurement_basis_list + [jabalize_data["measurements"]]
        )
        graph = jw.create_nxgraph_from_jabalize(jabalize_json_path)

        if jabalize_data["frameflags"]:
            logger.debug(
                "The following `consump_schedule` info were extracted from jabalize JSON:\n"
                f"paths.steps: {jabalize_data['steps']}\n"
                f"paths.space: {jabalize_data['space']}\n"
                f"paths.time: {jabalize_data['time']}"
            )
            consump_sched[-1] = jabalize_data["steps"]
            delta = max(delta, jabalize_data["space"])

        if graph.number_of_edges() > 0:
            _, sched = perform_substrate_scheduling(graph)
            prep_schedule[-1] = sched

        if graph.number_of_nodes() > 0:
            # We do dummy-style stitching of the current graph in `graph_items` & new graph from `jabalize_json_path`.
            no_of_curr_outputs = len(graph_items.output_nodes[-1]) if graph_items.output_nodes else 0
            if no_of_curr_outputs > 0:
                no_of_next_inputs = len(jabalize_data["statenodes"])
                if not no_of_curr_outputs == no_of_next_inputs:
                    raise RuntimeError(
                        f"The no_of_curr_outputs:{no_of_curr_outputs} mismatches no_of_next_inputs:{no_of_next_inputs}."
                    )
            big_n = big_n + len(graph) + no_of_curr_outputs

        input_nodes = (
            [jabalize_data["statenodes"]]
            if not graph_items.input_nodes
            else graph_items.input_nodes + [jabalize_data["statenodes"]]
        )
        output_nodes = (
            [jabalize_data["outputnodes"]]
            if not graph_items.output_nodes
            else graph_items.output_nodes + [jabalize_data["outputnodes"]]
        )

        return replace(
            graph_items,
            big_n=big_n,
            delta=delta,
            prep_sched=prep_schedule,
            input_nodes=input_nodes,
            output_nodes=output_nodes,
            consump_sched=consump_sched,
            measurement_basis_list=measurement_basis_list,
        )

    def generate_graph(self) -> JabalizerSchedGraphItems:
        """Generate the graph state and Pauli Frames info."""
        # graph_states = []
        blocks = self.num_subcircuits

        if self.graph_state_opt == "resume":
            for nn in range(blocks):
                suffix = "" if self.num_subcircuits == 1 else "_bb" + str(nn)
                jabalize_json_path = (
                    "output/" + self.circuit_fname + "/" + self.circuit_fname + suffix + "_all0init_jabalizeframes.json"
                )
                if Path(jabalize_json_path).is_file():
                    logger.info(f"Resuming calculations from existing {jabalize_json_path} file ...")
                else:
                    raise FileNotFoundError(f"Jabalize JSON file of {jabalize_json_path} does not exist.")

        elif self.graph_state_opt == "save":
            logger.info("RRE will create and save the graph state(s) and Pauli frames info as JSONs in output/ ...")
            # Importing outside top-level to avoid julia (pre-)compilations upon every call to RRE.
            import rigetti_resource_estimation.jabalizer_wrapper as jw  # pylint: disable=C0415

            for nn in range(blocks):
                suffix = "" if self.num_subcircuits == 1 else "_bb" + str(nn)
                jabalize_json_path = jw.get_algorithmic_graphdata_from_jabalizer(
                    circuit=self.circuits_qasm[nn],
                    circuit_fname=self.circuit_fname,
                    suffix=suffix,
                    pcorrections_flag=self.pcorrections_flag,
                )

        else:
            raise RuntimeError("Specify a valid 'graph_state_opt' for the 'jabalizer' compilation method.")

        graph_items = JabalizerSchedGraphItems(
            t_count_init=self.t_count_init, rz_count=self.rz_count, clifford_count_init=self.clifford_count_init
        )
        if self.num_subcircuits == 1:
            jabalize_json_path = (
                "output/" + self.circuit_fname + "/" + self.circuit_fname + "_all0init_jabalizeframes.json"
            )
            graph_items = self.append_graph_items(graph_items=graph_items, jabalize_json_path=jabalize_json_path)
        else:
            graph_items = self.stitch_graphs(blocks)

        return graph_items

    def stitch_graphs(self, num_widgets: int) -> JabalizerSchedGraphItems:
        """Stitch and unify graphs to build a unified graph states with distinct nodes.

        For resource estimation purposes, one does not need to formally stitch universal graphs. It would be sufficient
        just to accumulate schedules and keep track of graph size as we do below. Therefore, this module can be
        considered a dummy-style stitcher.

        :param num_widgets: number of widgets/blocks in the decomposed input algorithm, i.e. how many subcircuit QASM
            strings exist. Jabalize JSON files should exist for each widget.

        :returns:
            `graph`: the unified graph in the form of a NetworkX graph itself.
            `gen_schedule`: The measurement flow schedule created by Pauli Tracker during graph generation.
            `consump_schedule`: The measurement flow schedule created by Substrate Scheduler for graph consumption
                and algorithm execution.
        """
        # logger.debug(f"EdgeView for the initial graph state of the decomposed algorithm:\n{graph_states[0].edges}\n")

        # Creating the graph and schedules for the fist widget
        graph_items = JabalizerSchedGraphItems(
            t_count_init=self.t_count_init, rz_count=self.rz_count, clifford_count_init=self.clifford_count_init
        )

        for nn in range(num_widgets):
            jabalize_json_path = (
                "output/"
                + self.circuit_fname
                + "/"
                + self.circuit_fname
                + "_bb"
                + str(nn)
                + "_all0init_jabalizeframes.json"
            )
            graph_items = self.append_graph_items(graph_items=graph_items, jabalize_json_path=jabalize_json_path)

        return graph_items


def find_graph_info(
    est_method: str,
    circuits_qasm: list,
    rz_count: int,
    t_count_init: int,
    clifford_count_init: int,
    num_subcircuits: int,
    circuit_fname: str,
    graph_state_opt: Literal["no_compile", "save", "resume"],
    pcorrections_flag: bool,
) -> JabalizerSchedGraphItems:
    """Find the graph state and store its attributes based on given ``est_method``, ``circuit_qasm``, and graph options.

    If graph creation not required (as in `t_counting` method), it outputs `None` for the required number of logical
    nodes and other relevant quantities.

    :param est_method: The estimation method to perform resource estimations. The method will measure if further
        processing and pinpointing of other parameters, such as gate-synth `eps` is required. You can set it to either:
        't_counting': Considers the total T-count as a proxy for the graph's size and max degree to estimate all
        resources required (similar to the underlying approaches by other libraries such as LatticeSurgery.com and
        Microsoft Quantum Azure).
        'jabalizer': Use Jabilizer compilation tools to generate the graph explicitly.
    :param circuits_qasm: A list of OpenQASM2.0 input circuits.
    :param rz_count: number of the non-Clifford Rz gates associated with the original logical circuit.
    :param t_count_init: the initial T-count associated with the input logical circuit prior to Clifford+T
        decompositions.
    :param clifford_count_init: number of explicit Clifford gates in the initial logical circuit.
    :param num_subcircuits: number of subcircuits to compile.
    :param circuit_fname: the stem for the logical circuit file path.
    :param graph_state_opt: What to do concerning the graph state compilation. We explain the available options below.
        'no_compile': The graph compilation pipeline will NOT be executed (relevant for, e.g., 't_counting'
        approaches).
        'save': RRE compiles the circuit and attempts to generate the graph state and Pauli Frames info using Jabalizer
        compiler. The program will save BOTH the graph and logical_ops alongside all Pauli Frames info in two JSON files
        in the subdirectory `output/<circuit_fname>/`. The outputs will be named
        `<circuit_fname>_all0init_jabalize.json` and `<circuit_fname>_all0init_frames.json`, respectively.
        'resume': RRE will try to resume the calculations assuming a graph in the subdirectory
        `output/<circuit_fname>/<circuit_fname>_all0init_jabalize.json` already exists.

    :returns: A JabalizerSchedGraphItems object containing the graph state attributes.
    """
    if est_method == "jabalizer":
        logger.info("Initializing graph state processing for the Jabalizer method.")

        graph_compiler = GraphCompiler(
            circuits_qasm=circuits_qasm,
            graph_state_opt=graph_state_opt,
            circuit_fname=circuit_fname,
            num_subcircuits=num_subcircuits,
            t_count_init=t_count_init,
            rz_count=rz_count,
            clifford_count_init=clifford_count_init,
            pcorrections_flag=pcorrections_flag,
        )

        graph_items = graph_compiler.generate_graph()

    elif est_method == "t_counting":
        if graph_state_opt != "no_compile":
            raise ValueError(
                f"The est_method={est_method} and graph_adjlist_opt={graph_state_opt} cannot be selected together!"
            )
        graph_items = JabalizerSchedGraphItems(
            t_count_init=t_count_init, rz_count=rz_count, clifford_count_init=clifford_count_init, t_counting_cond=True
        )

    else:
        raise ValueError(f"The est_method={est_method} is not supported!")

    logger.debug(
        "The full graph_items object was constructed and has the following attributes:\n"
        f"N: {graph_items.big_n}\n"
        f"rz_count: {graph_items.rz_count}\n"
        f"t_count_init: {graph_items.t_count_init}\n"
        f"Delta: {graph_items.delta}\n"
        f"prep_sched: {graph_items.prep_sched}\n"
        f"consump_sched: {graph_items.consump_sched}\n"
        f"output_nodes: {graph_items.output_nodes}\n"
        f"measurement_basis_list: {graph_items.measurement_basis_list}\n"
    )

    return graph_items
